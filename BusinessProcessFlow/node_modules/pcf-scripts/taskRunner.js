"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const locale_generated_1 = require("./locale.generated");
const diagnostic_1 = require("./diagnostic");
const diagnosticMessages_generated_1 = require("./diagnosticMessages.generated");
const constants = require("./constants");
const buildcontext_1 = require("./buildcontext");
const locale_generated_2 = require("./locale.generated");
class TaskRunner {
    constructor(args, config) {
        this._colorize = true;
        if (args && args.noColor) {
            this._colorize = false;
        }
        this._diagnostics = new diagnostic_1.DiagnosticManager();
        this._args = args;
        this._config = config;
    }
    run(taskGroup) {
        return __awaiter(this, void 0, void 0, function* () {
            // Set locale
            try {
                yield this.setLocale();
            }
            catch (err) {
                console.log(`Error setting locale: ${err}`);
                return;
            }
            // Validate configuration
            this.validateConfiguration();
            if (!this.checkDiagnostics()) {
                return;
            }
            const tg = this.getTaskGroup(taskGroup);
            if (!this.checkDiagnostics()) {
                return;
            }
            const commandName = this._args._[0];
            // Create build context
            this.logMessage(commandName, `${locale_generated_2.translate(diagnosticMessages_generated_1.strings.initializing.key)}...`);
            this.initializeBuildContext();
            if (!this.checkDiagnostics()) {
                return;
            }
            // Run tasks
            for (let i = 0; i < Object.keys(tg).length; i++) {
                const task = tg[i];
                this.logMessage(commandName, `${task.getDescription()}...`);
                try {
                    task.setOptions({ colorize: this._colorize });
                    yield task.run(this._buildContext);
                }
                catch (err) {
                    if (err) {
                        throw err;
                    }
                    this.logError(commandName, `${locale_generated_2.translate(diagnosticMessages_generated_1.strings.failed.key)}:`);
                    this._diagnostics.flush(this._colorize);
                    return;
                }
            }
            this.logMessage(commandName, `${locale_generated_2.translate(diagnosticMessages_generated_1.strings.succeeded.key)}`);
            this._diagnostics.flush(this._colorize);
        });
    }
    getDiagnostics() {
        return this._diagnostics;
    }
    checkDiagnostics() {
        if (this._diagnostics.hasErrors()) {
            this._diagnostics.flush(this._colorize);
            return false;
        }
        return true;
    }
    // Sets the locale for the task runner
    setLocale() {
        return __awaiter(this, void 0, void 0, function* () {
            let locale;
            if (this._args && this._args.locale) {
                locale = this._args.locale;
            }
            else if (this._config && this._config.locale) {
                locale = this._config.locale;
            }
            try {
                yield locale_generated_1.configureLocale({
                    directory: path.resolve(__dirname, 'loc'),
                    diagnosticFileName: 'diagnosticMessages.localized.json',
                    locale: locale ? locale : constants.DEFAULT_LANGUAGE,
                    runtime: 'node'
                });
            }
            catch (err) {
                this._diagnostics.push({
                    code: 0,
                    category: 'Error',
                    key: undefined,
                    message: `Error setting locale ${err}`
                });
            }
        });
    }
    // Validates configuration parameters
    validateConfiguration() {
        if (!this._args || !this._args._ || this._args._.length === 0) {
            this._diagnostics.push(diagnosticMessages_generated_1.strings.pcf_scripts_not_valid_command);
        }
        if (this._args && this._args.buildMode) {
            this.validateBuildMode(this._args.buildMode);
        }
        if (this._config && this._config.buildMode) {
            this.validateBuildMode(this._config.buildMode);
        }
        if (this._config && this._config.controlsRoot && this._args && this._args.controlsRoot) {
            this.validateConfigPaths(this._config.controlsRoot, this._args.controlsRoot, 'controlsRoot');
        }
        if (this._config && this._config.outDir && this._args && this._args.outDir) {
            this.validateConfigPaths(this._config.outDir, this._args.outDir, 'outDir');
        }
    }
    initializeBuildContext() {
        let config = {
            'controlsRoot': '.',
            'outDir': constants.DEFAULT_OUT_DIR,
            'buildMode': constants.DEFAULT_BUILD_MODE,
            'locale': constants.DEFAULT_LANGUAGE
        };
        if (this._args && this._args.buildMode) {
            config.buildMode = this._args.buildMode;
        }
        else if (this._config && this._config.buildMode) {
            config.buildMode = this._config.buildMode;
        }
        if (config.buildMode === 'none') {
            config.buildMode = 'development';
        }
        if (this._args && this._args.outDir) {
            config.outDir = this._args.outDir;
        }
        else if (this._config && this._config.outDir) {
            config.outDir = this._config.outDir;
        }
        if (this._args && this._args.locale) {
            config.locale = this._args.locale;
        }
        else if (this._config && this._config.locale) {
            config.locale = this._config.locale;
        }
        this._buildContext = new buildcontext_1.BuildContext(this._diagnostics, config);
    }
    getTaskGroup(taskGroups) {
        const verb = this._args._[0];
        const tg = taskGroups[verb];
        if (!tg) {
            this._diagnostics.push(diagnosticMessages_generated_1.strings.pcf_scripts_not_valid_command);
        }
        return tg;
    }
    validateBuildMode(mode) {
        if (mode !== 'development' && mode !== 'production' && mode !== 'none') {
            this._diagnostics.pushA(diagnosticMessages_generated_1.strings.buildconfig_unsupported_build_mode, [mode]);
        }
    }
    validateConfigPaths(path1, path2, configName) {
        if (!this.arePathsEqual(path1, path2)) {
            this._diagnostics.pushA(diagnosticMessages_generated_1.strings.buildconfig_mismatched_configuration, [configName, constants.CONFIGURATION_FILE_NAME]);
        }
    }
    // Checks if two paths resolve to the same locale
    arePathsEqual(path1, path2) {
        if (path1 && path2) {
            const resolvedPath1 = path.resolve(path1);
            const resolvedPath2 = path.resolve(path2);
            const root1 = path.parse(resolvedPath1).root;
            const root2 = path.parse(resolvedPath2).root;
            // This check will need to be updated when running on file systems that care about case.
            return (root1.toLowerCase() === root2.toLowerCase()) &&
                (path.relative(root2, resolvedPath1).toLowerCase() === path.relative(root2, resolvedPath2).toLowerCase());
        }
        return path1 === path2;
    }
    logMessage(commandName, message) {
        console.log(`[${this.getCurrentTime()}] [${commandName}] ${message}`);
    }
    logError(commandName, message) {
        if (this._colorize) {
            console.log(constants.COLOR_RED_RESET, `[${this.getCurrentTime()}] [${commandName}] ${message}`);
        }
        else {
            console.log(`[${this.getCurrentTime()}] [${commandName}] ${message}`);
        }
    }
    getCurrentTime() {
        const dt = new Date();
        return dt.getHours() + ':' + dt.getMinutes() + ':' + dt.getSeconds();
    }
}
exports.TaskRunner = TaskRunner;
