"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="../../common/typings/controlmanifest.d.ts"/>
const clonedeep = require('lodash/clonedeep');
const path = require('path');
const fs = require('fs');
const controlmanifest_1 = require("./controlmanifest");
const constants = require("./constants");
const diagnosticMessages_generated_1 = require("./diagnosticMessages.generated");
class ManifestProcessor {
    constructor(manifestData, controlPath, diag) {
        this.resourcesMap = {};
        this.nameTracker = {};
        this.processedManifest = clonedeep(manifestData);
        this.controlAbsPath = path.resolve(controlPath);
        this.controlRoot = path.dirname(this.controlAbsPath);
        this.diag = diag;
        this.nameTracker[constants.BUNDLE_NAME] = 1;
    }
    // rename paths in <code> and <library>.<packaged_library> under <resources>
    // add built-by element as a child of control node; stamp PCF API version used
    getProcessedManifest() {
        this.addBuiltBy();
        this.stampApiVersion();
        this.processResources();
        return {
            processedManifest: new controlmanifest_1.ControlManifest(this.processedManifest),
            resourcesMap: this.resourcesMap
        };
    }
    // rename paths specified by preview-image attribute as well as <code> and <library>.<packaged_library> under <resources>
    processResources() {
        const resources = this.processedManifest.manifest.control.resources;
        const previewImagePath = this.processedManifest.manifest.control.$['preview-image'];
        if (previewImagePath) {
            this.processedManifest.manifest.control.$['preview-image'] = this.checkResourcePath(previewImagePath);
        }
        Object.keys(resources).forEach(resourceType => {
            if (resourceType === constants.CODE_ELEM_NAME) {
                // the xsd allows more than one <code> element, but our opinionated build will validate
                // there is only one <code> element
                resources[constants.CODE_ELEM_NAME][0].$.path = constants.BUNDLE_NAME;
            }
            else if (resourceType === constants.LIBRARY_ELEM_NAME) {
                resources[constants.LIBRARY_ELEM_NAME].forEach((lib) => {
                    const packagedLibs = lib.packaged_library;
                    if (packagedLibs) {
                        packagedLibs.forEach((packagedLib) => {
                            packagedLib.$.path = this.checkResourcePath(packagedLib.$.path);
                        });
                    }
                });
            }
            else {
                resources[resourceType].forEach((resource) => {
                    resource.$.path = this.checkResourcePath(resource.$.path);
                });
            }
        });
    }
    // add built-by element as a child of control node
    addBuiltBy() {
        const buildToolVersion = this.getPackageVersion(constants.PCF_SCRIPTS_PACKAGE_NAME);
        if (!buildToolVersion) {
            this.diag.pushA(diagnosticMessages_generated_1.strings.package_version_not_found, [constants.PCF_SCRIPTS_PACKAGE_NAME]);
            return;
        }
        this.processedManifest.manifest.control['built-by'] = {
            $: {
                name: constants.BUILD_TOOL_NAME,
                version: buildToolVersion
            }
        };
    }
    // obtain the version of the ComponentFramework API from the local package-lock.json and stamp it in CM.xml
    // optional parameter for unit test; return a boolean that indicates whether version info is found
    stampApiVersion() {
        const apiVersion = this.getPackageVersion(constants.COMPONENT_FRAMEWORK_PACKAGE_NAME);
        if (!apiVersion) {
            this.diag.pushA(diagnosticMessages_generated_1.strings.package_version_not_found, [constants.COMPONENT_FRAMEWORK_PACKAGE_NAME]);
            return;
        }
        this.processedManifest.manifest.control.$['api-version'] = apiVersion;
    }
    getPackageVersion(packageName) {
        let version;
        const pathToPackageLockJson = path.resolve(this.controlRoot, constants.PACKAGE_LOCK_JSON_PATH);
        const pathToPackageJson = path.resolve(this.controlRoot, constants.NODE_MODULES, packageName, constants.PACKAGE_JSON_PATH);
        // find version from package-lock.json first
        if (fs.existsSync(pathToPackageLockJson)) {
            const packageLockJson = require(pathToPackageLockJson);
            if (packageLockJson && packageLockJson.dependencies && packageLockJson.dependencies[packageName]) {
                version = packageLockJson.dependencies[packageName].version;
            }
        }
        // fallback to find version in that package's package.json in node_modules
        if (!version && fs.existsSync(pathToPackageJson)) {
            const packageJson = require(pathToPackageJson);
            if (packageJson && packageJson.version) {
                version = packageJson.version;
            }
        }
        return version;
    }
    // First check whether the resource's relative path points to a file within the control folder.
    // If so, preserve the folder structure in outdir. If not, check whether a resource's file name collides
    // with any other resources file. If so returns a new file name otherwise return original name.
    checkResourcePath(resourceRelativePath) {
        const resourceName = path.basename(resourceRelativePath);
        const resourceAbsPath = path.join(this.controlAbsPath, resourceRelativePath);
        const simplifiedRelativePath = path.relative(this.controlAbsPath, resourceAbsPath);
        let relativePathInOutDir;
        if (!simplifiedRelativePath.startsWith('..') && simplifiedRelativePath.length > 0) {
            relativePathInOutDir = simplifiedRelativePath;
        }
        else {
            relativePathInOutDir = resourceName;
        }
        // convert windows format to the path format in manifest
        relativePathInOutDir = relativePathInOutDir.replace(/\\/g, '/');
        if (this.nameTracker[relativePathInOutDir]) {
            const ext = path.extname(relativePathInOutDir);
            const suffix = this.nameTracker[relativePathInOutDir];
            // increment a number as suffix to differentiate files with existing names
            const newResourcePath = `${relativePathInOutDir.substring(0, relativePathInOutDir.length - ext.length)}${suffix}${ext}`;
            this.nameTracker[relativePathInOutDir]++;
            this.resourcesMap[resourceRelativePath] = newResourcePath;
            return newResourcePath;
        }
        else {
            this.nameTracker[relativePathInOutDir] = 1;
            this.resourcesMap[resourceRelativePath] = relativePathInOutDir;
            return relativePathInOutDir;
        }
    }
}
exports.ManifestProcessor = ManifestProcessor;
