"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="./typings/buildconfig.d.ts"/>
const fs = require('fs');
const path = require('path');
const controlcontext_1 = require("./controlcontext");
const constants = require("./constants");
const diagnosticMessages_generated_1 = require("./diagnosticMessages.generated");
// Context for building PCF controls
class BuildContext {
    constructor(diag, config) {
        this.config = config;
        this._diag = diag;
        if (config.controlsRoot) {
            this.controls = this.getControls();
        }
    }
    // Gets the controls root directory
    getControlsRoot() {
        return this.config.controlsRoot;
    }
    // Gets the output directory
    getOutDir() {
        return this.config.outDir;
    }
    // Gets the build mode
    getBuildMode() {
        return this.config.buildMode;
    }
    // Gets the locale
    getLocale() {
        return this.config.locale;
    }
    // Gets the diagnotic manager
    getDiagnostic() {
        return this._diag;
    }
    // Maps the specified callback for each control under the root directory
    mapControls(callback) {
        if (!this.config.controlsRoot) {
            this._diag.pushA(diagnosticMessages_generated_1.strings.buildconfig_not_defined, ['controlsRoot']);
            return Promise.reject();
        }
        if (!this.controls || this.controls.length === 0) {
            this._diag.pushA(diagnosticMessages_generated_1.strings.control_manifest_not_found, [constants.MANIFEST_INPUT_FILE_NAME]);
            return Promise.reject();
        }
        const results = this.controls.map((value) => { return callback(value); });
        return Promise.all(results);
    }
    // Gets the list of controls under the controls root directory
    getControls() {
        if (!this.config.controlsRoot) {
            return [];
        }
        // Exclude node_modules and outdir from control folder search
        const exludedFolders = [
            path.join(this.config.controlsRoot, 'node_modules')
        ];
        if (this.config.outDir) {
            exludedFolders.push(path.join(this.config.controlsRoot, this.config.outDir));
        }
        let controls = BuildContext.findControlFolders(this.config.controlsRoot, exludedFolders);
        return controls.map((controlPath) => {
            return new controlcontext_1.ControlContext(this._diag, controlPath);
        });
    }
    // Searches the provided directory for control folders.
    // A control folder is defined as containing a ControlManifest.Input.xml file.
    static findControlFolders(cwd, excludedFolders) {
        let results = [];
        if (fs.existsSync(path.join(cwd, constants.MANIFEST_INPUT_FILE_NAME))) {
            results.push(cwd);
            return results;
        }
        let folders = fs.readdirSync(cwd).filter(function (file) {
            return fs.statSync(path.join(cwd, file)).isDirectory();
        });
        folders.forEach((folder) => {
            const currentFolder = path.join(cwd, folder);
            if (excludedFolders && excludedFolders.find((elem) => elem === currentFolder)) {
                return;
            }
            else {
                results = results.concat(this.findControlFolders(currentFolder));
            }
        });
        return results;
    }
}
exports.BuildContext = BuildContext;
